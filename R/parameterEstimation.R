###
# Functions for parameter estimation
###

##' ginhomAverage function
##'
##' A function to estimate the inhomogeneous pair correlation function for a spatiotemporal point process. See equation (8) of Diggle P, Rowlingson B, Su T (2005).
##'
##' @param xyt an object of class stppp
##' @param spatial.intensity A spatialAtRisk object
##' @param temporal.intensity A temporalAtRisk object
##' @param time.window time interval contained in the interval xyt$tlim over which to compute average. Useful if there is a lot of data over a lot of time points.
##' @param rvals Vector of values for the argument r at which g(r) should be evaluated (see ?pcfinhom). There is a sensible default.
##' @param correction choice of edge correction to use, see ?pcfinhom, default is Ripley isotropic correction
##' @param suppresswarnings Whether or not to suppress warnings generated by pcfinhom
##' @param ... other parameters to be passed to pcfinhom, see ?pcfinhom
##' @return time average of inhomogenous pcf, equation (13) of Brix and Diggle 2001. 
##' @references 
##' \enumerate{
##'     \item Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
##'     \item Baddeley AJ, Moller J, Waagepetersen R (2000). Non-and semi-parametric estimation of interaction in inhomogeneous point patterns. Statistica Neerlandica, 54, 329-350.
##'     \item Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
##'     \item Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
##' }
##' @seealso \link{KinhomAverage}
##' @export

ginhomAverage <- function(xyt,spatial.intensity,temporal.intensity,time.window=xyt$tlim,rvals=NULL,correction="iso",suppresswarnings=FALSE,...){

    time.window <- sort(as.integer(time.window))

    verifyclass(spatial.intensity,"spatialAtRisk")
    verifyclass(temporal.intensity,"temporalAtRisk")

    density <- as.im(spatial.intensity)
    
    approxscale <- mean(sapply(xyt$t[xyt$t>=time.window[1] & xyt$t<=time.window[2]],temporal.intensity))
    
    den <- density
    den$v <- den$v * approxscale
   
    xyt$t <- as.integer(xyt$t)
    
    numsamp <- min(c(200,xyt$n))
    if(!suppresswarnings){
        if (is.null(rvals)){
            gin <- pcfinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den,...)
        }
        else{
            gin <- pcfinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den,r=rvals,...)
        }
    }
    else{
        if (is.null(rvals)){
            suppressWarnings(gin <- pcfinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den,...))
        }
        else{
            suppressWarnings(gin <- pcfinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den,r=rvals,...))
        }
    }
    r <- gin$r
    nam <- names(gin)
    nam <- nam[nam!="r"]
    
    tls <- sapply(time.window[1]:time.window[2],function(x){sum(xyt$t==x)})
    tls <- (time.window[1]:time.window[2])[tls!=0]
    ntls <- length(tls) 
    
    pb <- txtProgressBar(min=tls[1],max=rev(tls)[1],style=3)
    if(!suppresswarnings){
        pcf <- lapply(tls,function(t){setTxtProgressBar(pb,t);den<-density;den$v<-den$v*temporal.intensity(t);try(pcfinhom(xyt[xyt$t==t],lambda=den,r=r,...))})
    }
    else{
        suppressWarnings(pcf <- lapply(tls,function(t){setTxtProgressBar(pb,t);den<-density;den$v<-den$v*temporal.intensity(t);try(pcfinhom(xyt[xyt$t==t],lambda=den,r=r,...))}))
    }
    close(pb)         
    
    li <- as.list(pcf[[1]])
    ct <- 1
    if(ntls>1){
        for(i in 2:ntls){
            if ((class(pcf[[i]])[1]!="try-error")&&(npoints(xyt[xyt$t==tls[i]])>1)){
                li <- add.list(li,as.list(pcf[[i]]))
                ct <- ct + 1
            }
        }  
    }
    
    li <- smultiply.list(li,1/ct)  
    
    ginhom <- gin
    for (n in nam){
        idx <- which(names(ginhom)==n)
        ginhom[[idx]] <- li[[idx]]
    }
    attr(ginhom,"correction") <- correction
    cat("Returning an average of",ct,"curves\n")
    return(ginhom)
}


##' KinhomAverage function
##'
##' A function to estimate the inhomogeneous K function for a spatiotemporal point process. The method of computation is similar to
##' \link{ginhomAverage}, see eq (8) Diggle P, Rowlingson B, Su T (2005) to see how this is computed.
##'
##' @param xyt an object of class stppp
##' @param spatial.intensity A spatialAtRisk object
##' @param temporal.intensity A temporalAtRisk object
##' @param time.window time interval contained in the interval xyt$tlim over which to compute average. Useful if there is a lot of data over a lot of time points.
##' @param rvals Vector of values for the argument r at which the inhmogeneous K function should be evaluated (see ?Kinhom). There is a sensible default.
##' @param correction choice of edge correction to use, see ?Kinhom, default is Ripley isotropic correction
##' @param suppresswarnings Whether or not to suppress warnings generated by Kinhom
##' @return time average of inhomogenous K function. 
##' @references 
##' \enumerate{
##'     \item Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
##'     \item Baddeley AJ, Moller J, Waagepetersen R (2000). Non-and semi-parametric estimation of interaction in inhomogeneous point patterns. Statistica Neerlandica, 54, 329-350.
##'     \item Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
##'     \item Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
##' }
##' @seealso \link{ginhomAverage}
##' @export

KinhomAverage <- function(xyt,spatial.intensity,temporal.intensity,time.window=xyt$tlim,rvals=NULL,correction="iso",suppresswarnings=FALSE){

    time.window <- sort(as.integer(time.window))

    verifyclass(spatial.intensity,"spatialAtRisk")
    verifyclass(temporal.intensity,"temporalAtRisk")

    density <- as.im(spatial.intensity)
    
    approxscale <- mean(sapply(xyt$t[xyt$t>=time.window[1] & xyt$t<=time.window[2]],temporal.intensity))
    
    den <- density
    den$v <- den$v * approxscale
    
    xyt$t <- as.integer(xyt$t)
    
    numsamp <- min(c(200,xyt$n))
    if(!suppresswarnings){
        if (is.null(rvals)){
            Kin <- Kinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den)
        }
        else{
            Kin <- Kinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den,r=rvals)
        }
    }
    else{
        if (is.null(rvals)){
            suppressWarnings(Kin <- Kinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den))
        }
        else{
            suppressWarnings(Kin <- Kinhom(xyt[sample(1:xyt$n,numsamp,replace=FALSE)],lambda=den,r=rvals))
        }
    }
    r <- Kin$r
    nam <- names(Kin)
    nam <- nam[nam!="r"]
    
    tls <- sapply(time.window[1]:time.window[2],function(x){sum(xyt$t==x)})
    tls <- (time.window[1]:time.window[2])[tls!=0]
    ntls <- length(tls)  
    
    pb <- txtProgressBar(min=tls[1],max=rev(tls)[1],style=3)
    if(!suppresswarnings){
        pcf <- lapply(tls,function(t){setTxtProgressBar(pb,t);den<-density;den$v<-den$v*temporal.intensity(t);try(Kinhom(xyt[xyt$t==t],lambda=den,r=r))})
    }
    else{
        suppressWarnings(pcf <- lapply(tls,function(t){setTxtProgressBar(pb,t);den<-density;den$v<-den$v*temporal.intensity(t);try(Kinhom(xyt[xyt$t==t],lambda=den,r=r))}))
    }
    close(pb)      
    
    li <- as.list(pcf[[1]])
    ct <- 1
    if(ntls>1){
        for(i in 2:ntls){
            if ((class(pcf[[i]])[1] != "try-error")&&(npoints(xyt[xyt$t==tls[i]])>1)){
                li <- add.list(li,as.list(pcf[[i]]))
                ct <- ct + 1
            }
        }  
    }
    li <- smultiply.list(li,1/ct)  
    
    Kinhom <- Kin
    for (n in nam){
        idx <- which(names(Kinhom)==n)
        Kinhom[[idx]] <- li[[idx]]
    }
    attr(Kinhom,"correction") <- correction
    cat("Returning an average of",ct,"curves\n")
    return(Kinhom)
}



##' density.stppp function
##'
##' A wrapper function for \link{density.ppp}.
##'
##' @method density stppp
##' @param x an stppp object
##' @param bandwidth 'bandwidth' parameter, equivanent to parameter sigma in ?density.ppp ie standard deviation of isotropic Gaussian smoothing kernel.
##' @param ... additional arguments to be passed to density.ppp
##' @return bivariate density estimate of xyt; not this is a wrapper function for density.ppp
##' @seealso \link{density.ppp}
##' @export

density.stppp <- function(x,bandwidth=NULL,...){
    density.ppp(x,...,sigma=bandwidth)
}

##' Cvb function
##'
##' This function is used in \code{thetaEst} to estimate the temporal correlation parameter, theta.
##'
##' @param xyt object of class stppp
##' @param spatial.intensity bivariate density estimate of lambda, an object of class im (produced from density.ppp for example)
##' @param N number of integration points
##' @param spatial.covmodel spatial covariance model
##' @param covpars additional covariance parameters
##' @return a function, see below.
##' Computes Monte carlo estimate of function C(v;beta) in Brix and Diggle 2001 pp 829 (... note later corrigendum to paper (2003) corrects the expression given in this paper)
##' @references 
##' \enumerate{
##'     \item Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
##'     \item Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
##' }
##' @export

Cvb <- function(xyt,spatial.intensity,N=100,spatial.covmodel,covpars){
    verifyclass(spatial.intensity,"im")
    sar <- spatialAtRisk(list(X=spatial.intensity$xcol,Y=spatial.intensity$yrow,Zm=t(spatial.intensity$v)))
    gsx <- length(xvals(sar))
    gsy <- length(yvals(sar))
    xy <- cbind(rep(xvals(sar),gsy),rep(yvals(sar),each=gsx))
    wt <- as.vector(zvals(sar))
    wt[is.na(wt)] <- 0
    sidx <- sample(1:(gsx*gsy),N,prob=wt)
    xy <- xy[sidx,]
    pd <- as.vector(pairdist(xy))
    cvb <- function(nu,sigma,phi,theta){
        return(mean(exp(exp(-nu*theta)*gu(pd,sigma=sigma,phi=phi,model=spatial.covmodel,additionalparameters=covpars))-1))    
    }
    return(cvb)  
}  
